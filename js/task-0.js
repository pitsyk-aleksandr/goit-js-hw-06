/* --------------------------------------------------------------------------------------------- */
// Приклади з конспекту
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Ключове слово this
/* ============================================================================================= */
// Виконай рефакторинг методів об'єкта pizzaPalace, розставивши відсутні this
// в місцях звернення до властивостей і методів об'єкта.
/* --------------------------------------------------------------------------------------------- */
console.log(`Ключове слово this`);

const pizzaPalace = {
  pizzas: ['Supercheese', 'Smoked', 'Four meats'],
  checkPizza(pizzaName) {
    return this.pizzas.includes(pizzaName);
  },
  order(pizzaName) {
    const isPizzaAvailable = this.checkPizza(pizzaName);

    if (!isPizzaAvailable) {
      return `Sorry, there is no pizza named «${pizzaName}»`;
    }

    return `Order accepted, preparing «${pizzaName}» pizza`;
  },
};

console.log(pizzaPalace.order('Four meats')); // "Order accepted, preparing «Four meats» pizza"
console.log(pizzaPalace.order('Big Mike')); // "Sorry, there is no pizza named «Big Mike»"

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Метод call()
/* ============================================================================================= */
// foo.call(thisArg, arg1, arg2, ...)
//    thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції
//    arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції
/* --------------------------------------------------------------------------------------------- */
// створимо функцію greet, яка вітає різних користувачів готелю, кожен з яких представлений
// об'єктом з властивостями username і room.
// Функція приймає один параметр, str — рядок привітання.
/* --------------------------------------------------------------------------------------------- */
console.log(`Метод call()`);

function greet(str) {
  console.log(`${str}, ${this.username}, your room is ${this.room}!`);
}

const mango = {
  username: 'Mango',
  room: 27,
};

const poly = {
  username: 'Poly',
  room: 191,
};

/* --------------------------------------------------------------------------------------------- */
// За допомогою методу call ми можемо викликати функцію greet так, щоб значення this
// вказувало на потрібний об'єкт і використовувало значення його властивостей.
/* --------------------------------------------------------------------------------------------- */

greet.call(mango, 'Welcome'); // "Welcome, Mango, your room is 27!"
greet.call(poly, 'Aloha'); // "Aloha, Poly, your room is 191!"

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Метод apply()
/* ============================================================================================= */
// foo.apply(thisArg, [arg1, arg2, ...])
//    thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції.
//    arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції.
/* --------------------------------------------------------------------------------------------- */
// Метод apply є аналогом методу call.
// Відмінність у тому, що в методі apply() синтаксис передачі аргументів вимагає масиву,
// навіть якщо аргументи функції — це окремі значення.
/* --------------------------------------------------------------------------------------------- */
console.log(`Метод apply()`);

greet.apply(mango, ['Welcome']); // "Welcome, Mango, your room is 27!"
greet.apply(poly, ['Aloha']); // "Aloha, Poly, your room is 191!"

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Метод bind()
/* ============================================================================================= */
// const boundFoo = foo.bind(thisArg, arg1, arg2, ...)
//     thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції
//     arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції при її виклику
/* --------------------------------------------------------------------------------------------- */
// Методи call і apply викликають функцію «на місці», тобто одразу.
// Метод bind створює і повертає нову функцію, яка має заздалегідь встановлений контекст,
// і ця нова функція може бути викликана пізніше з будь-якими аргументами.
/* --------------------------------------------------------------------------------------------- */
console.log(`Метод bind()`);

const customer = {
  username: 'Jacob',
  sayHello() {
    console.log(`Hello, ${this.username}!`);
  },
};

customer.sayHello(); // "Hello, Jacob!"

// Коли ми використовуємо bind(), ми створюємо нову функцію greet.
// Ця нова функція завжди матиме правильний контекст і може використовувати властивість username об'єкта customer.
const greetBind = customer.sayHello.bind(customer);

greetBind(); // "Hello, Jacob!"

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Стрілочні функції
/* ============================================================================================= */
// Контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.
// Це означає, що this усередині стрілки посилається на контекст батьківської області видимості,
// в якій вона була оголошена, і ніколи не змінюється.
/* --------------------------------------------------------------------------------------------- */
// Що треба запам’ятати про this у стрілочних функціях?

// 1.Контекст **this** усередині стрілочної функції визначається місцем її оголошення, а не виклику.
// 2.Стрілочні функції ігнорують наявність суворого режиму.
//   Тому в глобальному контексті у стрілці завжди this посилається на об'єкт window.
// 3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення.
//   Методи call, apply і bind не впливають на значення this у стрілках.
/* --------------------------------------------------------------------------------------------- */
console.log(`Стрілочні функції`);

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Прототип об'єкта
/* ============================================================================================= */
// Метод Object.create(obj) створює і повертає новий об'єкт, зв'язуючи його з об'єктом obj.
// Властивість, яка зберігає посилання на прототип, називається [[Prototype]].
/* --------------------------------------------------------------------------------------------- */
// Зміни код таким чином, щоб об'єкт parent став прототипом для об'єкта у змінній сhild.
/* --------------------------------------------------------------------------------------------- */
console.log(`Прототип об'єкта`);

const parent = {
  name: 'Stacey',
  surname: 'Moore',
  age: 54,
  heritage: 'Irish',
};

const child = Object.create(parent);
child.name = 'Jason';
child.age = 27;

console.log(`child.surname`, child.surname); // "Moore"

// hasOwnProperty - Власна влвстивість об'єкту
console.log(
  `parent.hasOwnProperty("surname")`,
  parent.hasOwnProperty('surname')
); //true

console.log(`child.hasOwnProperty("surname")`, child.hasOwnProperty('surname')); //false

// Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта,
// використовується метод isPrototypeOf().
console.log(`parent.isPrototypeOf(child)`, parent.isPrototypeOf(child)); //true

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Перевірка прототипу
/* ============================================================================================= */
// Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта, використовується метод isPrototypeOf().

// objA.isPrototypeOf(objB)

// Метод перевіряє, чи є об'єкт objA прототипом для об’єкта objB
// Якщо так, повертає true, в іншому разі повертає false
/* --------------------------------------------------------------------------------------------- */
console.log(`Перевірка прототипу - objA.isPrototypeOf(objB)`);

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Власні і невласні властивості
/* ============================================================================================= */
// Невласна властивість об'єкта obj — це властивість його прототипу.

// Для того щоб перевірити, чи є в об'єкті власна властивість, використовується метод
// obj.hasOwnProperty(key).

// Цей метод перевіряє наявність власної властивості з ім'ям key
// і повертає true, якщо є, і false в іншому випадку.
/* --------------------------------------------------------------------------------------------- */
console.log(`Власні і невласні властивості - obj.hasOwnProperty(key)`);

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Перебір власних властивостей
/* ============================================================================================= */
// Оператор in, який використовується в циклі for...in,
// не розрізняє власні властивості об'єкта і його прототипу.
/* --------------------------------------------------------------------------------------------- */
// Для вибору саме власних властивостей під час перебору циклом for...in необхідно на кожній
// ітерації додати перевірку на власну властивість методом obj.hasOwnProperty(key).
// Цей метод повертає true, якщо властивість з іменем key належить об'єкту obj,
// а не його прототипу, в іншому разі — false.
/* --------------------------------------------------------------------------------------------- */
console.log(`Перебір власних властивостей`);

const animal = { legs: 4 };
const dog = Object.create(animal);
dog.name = 'Mango';

for (const key in dog) {
  console.log(key); // "name" "legs"
}

for (const key in dog) {
  if (dog.hasOwnProperty(key)) {
    console.log(key); // "name"
  }
}

/* --------------------------------------------------------------------------------------------- */
// Методи Object.keys(obj) і Object.values(obj) повертають масив тільки власних ключів або значень
// тільки власних властивостей об'єкта obj, без необхідності додаткових перевірок.
// Через це на практиці використовують саме їх із циклом for...of, замість for...in і hasOwnProperty.
/* --------------------------------------------------------------------------------------------- */

console.log(Object.keys(dog)); // ["name"]
console.log(Object.values(dog)); // ["Mango"]

for (const key of Object.keys(dog)) {
  console.log(key); // "name"
}

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Ланцюжки прототипів
/* ============================================================================================= */
// Об'єкт, який виступає прототипом для іншого об'єкта, також може мати свій прототип.
// Наприкінці ланцюжка прототипів завжди знаходиться посилання на базовий клас,
// від якого походить тип даних у ланцюжку.
// У нашому випадку  — це ancestor об'єкт, тому в кінці ланцюжка буде посилання на клас Object.
/* --------------------------------------------------------------------------------------------- */
// Зміни код, побудувавши ланцюжок прототипів таким чином,
// щоб об'єкт ancestor був прототипом для parent, а той, своєю чергою, був прототипом для child.
/* --------------------------------------------------------------------------------------------- */
console.log(`Ланцюжки прототипів`);

const ancestor = {
  name: 'Paul',
  age: 83,
  surname: 'Dawson',
  heritage: 'Irish',
};

const parent1 = Object.create(ancestor);
parent1.name = 'Stacey';
parent1.surname = 'Moore';
parent1.age = 54;

const child1 = Object.create(parent1);
child1.name = 'Jason';
child1.age = 27;

console.log(child1);
console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Оголошення класу
/* ============================================================================================= */
// Оголошення класу має такий синтаксис:
//   ключове слово class
//   ім’я класу 
//   тіло класу у фігурних дужках
/* --------------------------------------------------------------------------------------------- */
// Використовуючи ключове слово class, оголоси клас Car з порожнім тілом.
/* --------------------------------------------------------------------------------------------- */
console.log(`Оголошення класу`);
class Car0 {}

// Створення екземпяру класса
const car_1 = new Car0();

console.log(`car_1`, car_1);

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Конструктор класу
/* ============================================================================================= */
// Для ініціалізації екземпляра класу використовується метод constructor.
/* --------------------------------------------------------------------------------------------- */
// Додай класу Car метод constructor, який приймає три параметри:
//   brand - марка автомобіля
//   model - модель автомобіля
//   price - ціна автомобіля
// Клас Car повинен створювати об'єкт з одноіменними властивостями brand, model і price, які
// отримують свої значення з аргументів, переданих при створенні нового екземпляра за допомогою оператора new.
/* --------------------------------------------------------------------------------------------- */
console.log(`Конструктор класу`);

class Car1 {
  constructor(brand, model, price) {
    this.brand = brand;
    this.model = model;
    this.price = price;
  }
}

const carAudi = new Car1('Audi', 'Q3', 36000);
console.log(`carAudi`, carAudi); // {brand: "Audi", model: "Q3", price: 36000}

const carNissan = new Car1('Nissan', 'Murano', 31700);
console.log(`carNissan`, carNissan); //  {brand: "Nissan", model: "Murano", price: 31700}

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Об'єкт параметрів
/* ============================================================================================= */
//
/* --------------------------------------------------------------------------------------------- */
// Виконай рефакторинг класу Car таким чином, щоб він приймав один параметр -
// об'єкт з властивостями brand, model і price.
/* --------------------------------------------------------------------------------------------- */
console.log(`Об'єкт параметрів`);

class Car2 {
  constructor(params) {
    this.brand = params.brand;
    this.model = params.model;
    this.price = params.price;
  }
}

const carBmw = new Car2({ brand: 'BMW', model: 'X5', price: 58900 });
console.log(`carBmw`, carBmw); // {brand: "BMW", model: "X5", price: 58900}

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Методи класу
/* ============================================================================================= */
// Для роботи з властивостями майбутнього екземпляра використовуються методи класу.
// Методи класу — це функції, які будуть доступні екземпляру в його прототипі.
/* --------------------------------------------------------------------------------------------- */
// Додай класу Car два методи.
//    getPrice() - повертає значення властивості price з об'єкта, який буде його викликати.
//    changePrice(newPrice) - оновлює значення властивості price в об'єкта,
//          який буде його викликати на значення параметра newPrice.
/* --------------------------------------------------------------------------------------------- */
console.log(`Методи класу`);

class Car3 {
  constructor(params) {
    this.brand = params.brand;
    this.model = params.model;
    this.price = params.price;
  }
  getPrice() {
    return this.price;
  }
  changePrice(newPrice) {
    this.price = newPrice;
  }
}

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Приватні властивості
/* ============================================================================================= */
// Додаючи до імені властивості на початку символ #, ми робимо її приватною.
// Оголошення приватної властивості до ініціалізації в конструкторі є обов'язковим.
// Для того щоб отримати або змінити значення приватної властивості використовуються публічні методи.
/* --------------------------------------------------------------------------------------------- */
// Виконай рефакторинг класу Car таким чином, щоб властивість brand була приватною, 
// і додай два методи для публічного інтерфейсу, для читання і зміни цієї властивості.
//    getBrand() - повертає значення приватної властивості brand.
//    changeBrand(newBrand) - змінює значення приватної властивості brand на newBrand.
/* --------------------------------------------------------------------------------------------- */
console.log(`Приватні властивості`);

class Car4 {
  #brand;
  model;
  price;

  constructor(params) {
    this.#brand = params.brand;
    this.model = params.model;
    this.price = params.price;
  }

  getPrice() {
    return this.price;
  }

  changePrice(newPrice) {
    this.price = newPrice;
  }

  getBrand() {
    return this.#brand;
  }

  changeBrand(newBrand) {
    this.#brand = newBrand;
  }
}

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Приватні методи
/* ============================================================================================= */
// Додаючи до назви методу на початку символ #, ми робимо його приватним.
// Приватний метод не доступний ззовні класу, тому користувачі (або інші розробники) 
// не можуть його викликати напряму. 
// Вони можуть лише використовувати публічний метод, який у свою чергу використовує приватний метод.
/* --------------------------------------------------------------------------------------------- */
console.log(`Приватні методи`);

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Геттери і сеттери
/* ============================================================================================= */
//
/* --------------------------------------------------------------------------------------------- */
// Виконай рефакторинг класу Car. 
// Додатково до приватної властивості #brand зроби приватними властивості model і price. 
// Стандартизуй публічний інтерфейс класу, замінивши вже оголошені методи на геттери та сеттери
// brand, model і price, для взаємодії з приватними властивостями.
/* --------------------------------------------------------------------------------------------- */
console.log(`Геттери і сеттери`);

class Car5 {
  #brand;
  #model;
  #price;

  constructor(params) {
    this.#brand = params.brand;
    this.#model = params.model;
    this.#price = params.price;
  }

  get brand() {
    return this.#brand;
  }

  set brand(newBrand) {
    this.#brand = newBrand;
  }

  get model() {
    return this.#model;
  }

  set model(newModel) {
    this.#model = newModel;
  }

  get price() {
    return this.#price;
  }

  set price(newPrice) {
    this.#price = newPrice;
  }
}

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Статичні властивості
/* ============================================================================================= */
// Властивості, що доступні тільки класові, але не його екземплярам — це статичні властивості. 
// Вони корисні для зберігання інформації, що стосується класу.
// Статичні властивості оголошуються в тілі класу. 
// Перед ім'ям властивості додається ключове слово static. 
// Статичні властивості можна використовувати як у методах класу, так і поза класом.
// У екземпляра немає доступу до статичних властивостей класу.
/* --------------------------------------------------------------------------------------------- */
// Виконай рефакторинг класу Car. 
// Додай публічну статичну властивість maxPrice зі значенням число 50000 - максимально допустима ціна автомобіля.
// Додай сеттеру price перевірку значення параметра newPrice, що передається. 
// Якщо воно більше за maxPrice, сеттер нічого не робить, а якщо менше або дорівнює, то перезаписує ціну автомобіля.
/* --------------------------------------------------------------------------------------------- */
console.log(`Статичні властивості`);

class Car6 {
  #price;
  static maxPrice = 50000; 

  constructor(params) {
    this.#price = params.price;
  }

  get price() {
    return this.#price;
  }

  set price(newPrice) {
    if (newPrice > Car6.maxPrice) {
      return;
    }
    this.#price = newPrice;
  }
}

const audi = new Car6({ price: 35000 });
console.log(audi.price); // 35000

audi.price = 49000;
console.log(audi.price); // 49000

audi.price = 51000;
console.log(audi.price); // 49000

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Статичні методи
/* ============================================================================================= */
// У класі можна оголосити не тільки методи майбутнього екземпляра, а й статичні методи. 
// Статичні методи — це методи, доступні тільки класу. 
// Вони можуть бути публічні та приватні. 
// Синтаксис оголошення статичних методів майже аналогічний статичним властивостям. 
// Єдина відмінність — значенням буде метод.
/* --------------------------------------------------------------------------------------------- */
// Додай класу Car публічний статичний метод checkPrice(price), що приймає ціну автомобіля. 
// Метод повинен порівняти значення параметра price і приватної статичної властивості maxPrice.
// Якщо ціна автомобіля перевищує максимальну, метод повинен повернути рядок "Error! Price exceeds the maximum".
// В іншому випадку метод повинен повернути рядок "Success! Price is within acceptable limits".
/* --------------------------------------------------------------------------------------------- */
console.log(`Статичні методи`);

class Car {
  static #maxPrice = 50000;

  static checkPrice(price) {
    if (price > this.#maxPrice) {
      return "Error! Price exceeds the maximum";
    } else {
      return "Success! Price is within acceptable limits";
    }
  }

  constructor(params) {
    this.price = params.price;
  }
}

const audiCar = new Car({ price: 36000 });
const bmwCar = new Car({ price: 64000 });

console.log(Car.checkPrice(audiCar.price)); // "Success! Price is within acceptable limits"
console.log(Car.checkPrice(bmwCar.price)); // "Error! Price exceeds the maximum"


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Наслідування класів
/* ============================================================================================= */
// Ключове слово extends дозволяє реалізувати наслідування класів, 
// коли один клас (дочірній, похідний) наслідує властивості й методи іншого класу (батьківського).
/* --------------------------------------------------------------------------------------------- */
// У застосунку потрібен адміністратор з можливістю додавати пошти користувачів у чорний список.

// Оголоси клас Admin, який наслідує від класу User
// Додай класу Admin публічну статичну властивість role (рівень доступу), 
// значення якої — це об'єкт {BASIC: "basic", SUPERUSER: "superuser"}
/* --------------------------------------------------------------------------------------------- */
console.log(`Наслідування класів`);

class User0 {
  constructor(email) {
    this.email = email;
  }

  get email() {
    return this.email;
  }

  set email(newEmail) {
    this.email = newEmail;
  }
}

class Admin0 extends User0 {
  static role = {BASIC: "basic", SUPERUSER: "superuser"};
}

console.log(`Admin0.role.BASIC`,Admin0.role.BASIC); // "basic"
console.log(`Admin0.role.SUPERUSER`,Admin0.role.SUPERUSER); // "superuser"
console.dir(Admin0);

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

/* ============================================================================================= */
// Конструктор дочірнього класу
/* ============================================================================================= */
// У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — 
// це псевдонім конструктора батьківського класу.
// В іншому випадку при спробі звернутися до this у конструкторі дочірнього класу виникне помилка.
// Під час виклику конструктора батьківського класу передаємо необхідні йому аргументи 
// для ініціалізації властивостей.
/* --------------------------------------------------------------------------------------------- */
// Додай класу Admin метод constructor, який приймає один параметр params - 
// об'єкт налаштувань з двома властивостями email і access. 
// Додай класу Admin публічну властивість access, 
// значення якої буде передаватися під час виклику конструктора.
/* --------------------------------------------------------------------------------------------- */
console.log(`Конструктор дочірнього класу`);

class User1 {
  email;

  constructor(email) {
    this.email = email;
  }

  get email() {
    return this.email;
  }

  set email(newEmail) {
    this.email = newEmail;
  }
}

class Admin1 extends User1 {
  access;

  constructor(params) {
    super(params.email);
    
    this.access = params.access;
  }

  static role = {
    BASIC: "basic",
    SUPERUSER: "superuser",
  };
  
}

const mangoNew = new Admin1({
  email: "mango@mail.com",
  access: Admin1.role.SUPERUSER,
});

console.log(mangoNew.email); // "mango@mail.com"
console.log(mangoNew.access); // "superuser"


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */


/* ============================================================================================= */
// Методи дочірнього класу
/* ============================================================================================= */
// Дочірній клас може використовувати методи та властивості батьківського класу. 
// Крім цього, у дочірньому класі можна оголошувати методи, які будуть доступні тільки його екземплярам.
/* --------------------------------------------------------------------------------------------- */
// Додай класу Admin наступні властивості і методи.

// Публічну властивість blacklistedEmails для зберігання чорного списку поштових адрес користувачів. 
// Значення за замовчуванням — це порожній масив.

// Публічний метод blacklist(email) для додавання пошти у чорний список. 
// Метод повинен додавати значення параметра email в масив, що зберігається у властивості blacklistedEmails.

// Публічний метод isBlacklisted(email) для перевірки пошти у чорному списку. 
// Метод повинен перевіряти наявність значення параметра email в масиві, що зберігається 
// у властивості blacklistedEmails, і повертати true або false.
/* --------------------------------------------------------------------------------------------- */
console.log(`Методи дочірнього класу`);

class User {
  email;

  constructor(email) {
    this.email = email;
  }

  get email() {
    return this.email;
  }

  set email(newEmail) {
    this.email = newEmail;
  }
}


class Admin extends User {
  blacklistedEmails = [];

  static role = {
    BASIC: "basic",
    SUPERUSER: "superuser",
  };

  constructor(params) {
    super(params.email);
    this.access = params.access;
  }

  blacklist(email) {
    this.blacklistedEmails.push(email);
  }

  isBlacklisted(email) {
    return this.blacklistedEmails.includes(email);
  }

}

const mango2 = new Admin({
  email: "mango@mail.com",
  access: Admin.role.SUPERUSER,
});

console.log(mango2);

console.log(mango2.email); // "mango@mail.com"
console.log(mango2.access); // "superuser"

mango2.blacklist("poly@mail.com");

console.log(mango2.blacklistedEmails); // ["poly@mail.com"]
console.log(mango2.isBlacklisted("mango@mail.com")); // false
console.log(mango2.isBlacklisted("poly@mail.com")); // true

console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */


/* ============================================================================================= */
// 
/* ============================================================================================= */
// 
/* --------------------------------------------------------------------------------------------- */
// 
/* --------------------------------------------------------------------------------------------- */
console.log(``);


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */


/* ============================================================================================= */
// 
/* ============================================================================================= */
// 
/* --------------------------------------------------------------------------------------------- */
// 
/* --------------------------------------------------------------------------------------------- */
console.log(``);


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */


/* ============================================================================================= */
// 
/* ============================================================================================= */
// 
/* --------------------------------------------------------------------------------------------- */
// 
/* --------------------------------------------------------------------------------------------- */
console.log(``);


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */


/* ============================================================================================= */
// 
/* ============================================================================================= */
// 
/* --------------------------------------------------------------------------------------------- */
// 
/* --------------------------------------------------------------------------------------------- */
console.log(``);


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */


/* ============================================================================================= */
// 
/* ============================================================================================= */
// 
/* --------------------------------------------------------------------------------------------- */
// 
/* --------------------------------------------------------------------------------------------- */
console.log(``);


console.log('-'.repeat(40));
/* --------------------------------------------------------------------------------------------- */

